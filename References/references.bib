
@article{navarro_practical_nodate,
	title = {Practical, transparent operating system support for superpages},
	abstract = {Most general-purpose processors provide support for memory pages of large sizes, called superpages. Superpages enable each entry in the translation lookaside buffer ({TLB}) to map a large physical memory region into a virtual address space. This dramatically increases {TLB} coverage, reduces {TLB} misses, and promises performance improvements for many applications. However, supporting superpages poses several challenges to the operating system, in terms of superpage allocation and promotion tradeoffs, fragmentation control, etc. We analyze these issues, and propose the design of an effective superpage management system. We implement it in {FreeBSD} on the Alpha {CPU}, and evaluate it on real workloads and benchmarks. We obtain substantial performance beneﬁts, often exceeding 30\%; these beneﬁts are sustained even under stressful workload scenarios.},
	author = {Navarro, Juan},
	langid = {english},
	file = {Navarro - Practical, transparent operating system support fo.pdf:/Users/akilan/Zotero/storage/9RBYAPGM/Navarro - Practical, transparent operating system support fo.pdf:application/pdf},
}

@inproceedings{panwar_hawkeye_2019,
	location = {Providence {RI} {USA}},
	title = {{HawkEye}: Efficient Fine-grained {OS} Support for Huge Pages},
	isbn = {978-1-4503-6240-5},
	url = {https://dl.acm.org/doi/10.1145/3297858.3304064},
	doi = {10.1145/3297858.3304064},
	shorttitle = {{HawkEye}},
	eventtitle = {{ASPLOS} '19: Architectural Support for Programming Languages and Operating Systems},
	pages = {347--360},
	booktitle = {Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {{ACM}},
	author = {Panwar, Ashish and Bansal, Sorav and Gopinath, K.},
	urldate = {2024-05-27},
	date = {2019-04-04},
	langid = {english},
	file = {Full Text PDF:/Users/akilan/Zotero/storage/VQLCKYCA/Panwar et al. - 2019 - HawkEye Efficient Fine-grained OS Support for Hug.pdf:application/pdf},
}

@article{basu_efficient_nodate,
	title = {Efficient Virtual Memory for Big Memory Servers},
	abstract = {Our analysis shows that many “big-memory” server workloads, such as databases, in-memory caches, and graph analytics, pay a high cost for page-based virtual memory. They consume as much as 10\% of execution cycles on {TLB} misses, even using large pages. On the other hand, we find that these workloads use read-write permission on most pages, are provisioned not to swap, and rarely benefit from the full flexibility of page-based virtual memory.},
	author = {Basu, Arkaprava and Gandhi, Jayneel and Chang, Jichuan and Hill, Mark D and Swift, Michael M},
	langid = {english},
	file = {Basu et al. - Efficient Virtual Memory for Big Memory Servers.pdf:/Users/akilan/Zotero/storage/JJ5M79Q9/Basu et al. - Efficient Virtual Memory for Big Memory Servers.pdf:application/pdf},
}

@inproceedings{karakostas_redundant_2015,
	location = {Portland Oregon},
	title = {Redundant memory mappings for fast access to large memories},
	isbn = {978-1-4503-3402-0},
	url = {https://dl.acm.org/doi/10.1145/2749469.2749471},
	doi = {10.1145/2749469.2749471},
	abstract = {Page-based virtual memory improves programmer productivity, security, and memory utilization, but incurs performance overheads due to costly page table walks after {TLB} misses. This overhead can reach 50\% for modern workloads that access increasingly vast memory with stagnating {TLB} sizes. To reduce the overhead of virtual memory, this paper proposes Redundant Memory Mappings ({RMM}), which leverage ranges of pages and provides an efﬁcient, alternative representation of many virtual-to-physical mappings. We deﬁne a range be a subset of process’s pages that are virtually and physically contiguous. {RMM} translates each range with a single range table entry, enabling a modest number of entries to translate most of the process’s address space. {RMM} operates in parallel with standard paging and uses a software range table and hardware range {TLB} with arbitrarily large reach. We modify the operating system to automatically detect ranges and to increase their likelihood with eager page allocation. {RMM} is thus transparent to applications. We prototype {RMM} software in Linux and emulate the hardware. {RMM} performs substantially better than paging alone and huge pages, and improves a wider variety of workloads than direct segments (one range per program), reducing the overhead of virtual memory to less than 1\% on average.},
	eventtitle = {{ISCA} '15: The 42nd Annual International Symposium on Computer Architecture},
	pages = {66--78},
	booktitle = {Proceedings of the 42nd Annual International Symposium on Computer Architecture},
	publisher = {{ACM}},
	author = {Karakostas, Vasileios and Gandhi, Jayneel and Ayar, Furkan and Cristal, Adrián and Hill, Mark D. and {McKinley}, Kathryn S. and Nemirovsky, Mario and Swift, Michael M. and Ünsal, Osman},
	urldate = {2024-05-27},
	date = {2015-06-13},
	langid = {english},
	file = {Karakostas et al. - 2015 - Redundant memory mappings for fast access to large.pdf:/Users/akilan/Zotero/storage/8JECES24/Karakostas et al. - 2015 - Redundant memory mappings for fast access to large.pdf:application/pdf},
}

@article{chen_flexpointer_2023,
	title = {{FlexPointer}: Fast Address Translation Based on Range {TLB} and Tagged Pointers},
	volume = {20},
	issn = {1544-3566, 1544-3973},
	url = {https://dl.acm.org/doi/10.1145/3579854},
	doi = {10.1145/3579854},
	shorttitle = {{FlexPointer}},
	abstract = {Page-based virtual memory relies on {TLBs} to accelerate the address translation. Nowadays, the gap between application workloads and the capacity of {TLB} continues to grow, bringing many costly {TLB} misses and making the {TLB} a performance bottleneck. Previous studies seek to narrow the gap by exploiting the contiguity of physical pages. One promising solution is to group pages that are both virtually and physically contiguous into a memory range. Recording range translations can greatly increase the {TLB} reach, but ranges are also hard to index because they have arbitrary bounds. The processor has to compare against all the boundaries to determine which range an address falls in, which restricts the usage of memory ranges.
            In this article, we propose a tagged-pointer-based scheme, {FlexPointer}, to solve the range indexing problem. The core insight of {FlexPointer} is that large memory objects are rare, so we can create memory ranges based on such objects and assign each of them a unique {ID}. With the range {ID} integrated into pointers, we can index the range {TLB} with {IDs} and greatly simplify its structure. Moreover, because the {ID} is stored in the unused bits of a pointer and is not manipulated by the address generation, we can shift the range lookup to an earlier stage, working in parallel with the address generation. According to our trace-based simulation results, {FlexPointer} can reduce nearly all the L1 {TLB} misses, and page walks for a variety of memory-intensive workloads. Compared with a 4K-page baseline system, {FlexPointer} shows a 14\% performance improvement on average and up to 2.8x speedup in the best case. For other workloads, {FlexPointer} shows no performance degradation.},
	pages = {1--24},
	number = {2},
	journaltitle = {{ACM} Transactions on Architecture and Code Optimization},
	shortjournal = {{ACM} Trans. Archit. Code Optim.},
	author = {Chen, Dongwei and Tong, Dong and Yang, Chun and Yi, Jiangfang and Cheng, Xu},
	urldate = {2024-05-27},
	date = {2023-06-30},
	langid = {english},
	file = {Full Text PDF:/Users/akilan/Zotero/storage/L9XGZDFK/Chen et al. - 2023 - FlexPointer Fast Address Translation Based on Ran.pdf:application/pdf},
}

@article{woodruff_cheri_2019,
	title = {{CHERI} Concentrate: Practical Compressed Capabilities},
	volume = {68},
	rights = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/{IEEE}.html},
	issn = {0018-9340, 1557-9956, 2326-3814},
	url = {https://ieeexplore.ieee.org/document/8703061/},
	doi = {10.1109/TC.2019.2914037},
	shorttitle = {{CHERI} Concentrate},
	abstract = {We present {CHERI} Concentrate, a new fat-pointer compression scheme applied to {CHERI}, the most developed capability-pointer system at present. Capability fat pointers are a primary candidate to enforce ﬁne-grained and non-bypassable security properties in future computer systems, although increased pointer size can severely affect performance. Thus, several proposals for capability compression have been suggested elsewhere that do not support legacy instruction sets, ignore features critical to the existing software base, and also introduce design inefﬁciencies to {RISC}-style processor pipelines. {CHERI} Concentrate improves on the state-of-the-art region-encoding efﬁciency, solves important pipeline problems, and eases semantic restrictions of compressed encoding, allowing it to protect a full legacy software stack. We present the ﬁrst quantitative analysis of compiled capability code, which we use to guide the design of the encoding format. We analyze and extend logic from the open-source {CHERI} prototype processor design on {FPGA} to demonstrate encoding efﬁciency, minimize delay of pointer arithmetic, and eliminate additional load-to-use delay. To verify correctness of our proposed high-performance logic, we present a {HOL}4 machine-checked proof of the decode and pointer-modify operations. Finally, we measure a 50\% to 75\% reduction in L2 misses for many compiled C-language benchmarks running under a commodity operating system using compressed 128-bit and 64-bit formats, demonstrating both compatibility with and increased performance over the uncompressed, 256-bit format.},
	pages = {1455--1469},
	number = {10},
	journaltitle = {{IEEE} Transactions on Computers},
	shortjournal = {{IEEE} Trans. Comput.},
	author = {Woodruff, Jonathan and Joannou, Alexandre and Xia, Hongyan and Fox, Anthony and Norton, Robert M. and Chisnall, David and Davis, Brooks and Gudka, Khilan and Filardo, Nathaniel W. and Markettos, A. Theodore and Roe, Michael and Neumann, Peter G. and Watson, Robert N. M. and Moore, Simon W.},
	urldate = {2024-05-27},
	date = {2019-10-01},
	langid = {english},
	file = {Woodruff et al. - 2019 - CHERI Concentrate Practical Compressed Capabiliti.pdf:/Users/akilan/Zotero/storage/3SZUIWQ5/Woodruff et al. - 2019 - CHERI Concentrate Practical Compressed Capabiliti.pdf:application/pdf},
}

@online{noauthor_capability-based_nodate,
	title = {Capability-Based Computer Systems},
	url = {https://homes.cs.washington.edu/~levy/capabook/},
	urldate = {2024-06-07},
	file = {Capability-Based Computer Systems:/Users/akilan/Zotero/storage/IAAG6ZF3/capabook.html:text/html},
}

@article{woodruff_cheri_2014,
	title = {The {CHERI} capability model: revisiting {RISC} in an age of risk},
	volume = {42},
	issn = {0163-5964},
	url = {https://doi.org/10.1145/2678373.2665740},
	doi = {10.1145/2678373.2665740},
	shorttitle = {The {CHERI} capability model},
	abstract = {Motivated by contemporary security challenges, we reevaluate and refine capability-based addressing for the {RISC} era. We present {CHERI}, a hybrid capability model that extends the 64-bit {MIPS} {ISA} with byte-granularity memory protection. We demonstrate that {CHERI} enables language memory model enforcement and fault isolation in hardware rather than software, and that the {CHERI} mechanisms are easily adopted by existing programs for efficient in-program memory safety. In contrast to past capability models, {CHERI} complements, rather than replaces, the ubiquitous page-based protection mechanism, providing a migration path towards deconflating data-structure protection and {OS} memory management. Furthermore, {CHERI} adheres to a strict {RISC} philosophy: it maintains a load-store architecture and requires only singlecycle instructions, and supplies protection primitives to the compiler, language runtime, and operating system. We demonstrate a mature {FPGA} implementation that runs the {FreeBSD} operating system with a full range of software and an open-source application suite compiled with an extended {LLVM} to use {CHERI} memory protection. A limit study compares published memory safety mechanisms in terms of instruction count and memory overheads. The study illustrates that {CHERI} is performance-competitive even while providing assurance and greater flexibility with simpler hardware},
	pages = {457--468},
	number = {3},
	journaltitle = {{ACM} {SIGARCH} Computer Architecture News},
	shortjournal = {{SIGARCH} Comput. Archit. News},
	author = {Woodruff, Jonathan and Watson, Robert N.M. and Chisnall, David and Moore, Simon W. and Anderson, Jonathan and Davis, Brooks and Laurie, Ben and Neumann, Peter G. and Norton, Robert and Roe, Michael},
	urldate = {2024-06-07},
	date = {2014-06-14},
}

@article{miller_towards_nodate,
	title = {Towards a Uniﬁed Approach to Access Control and Concurrency Control},
	author = {Miller, Mark Samuel},
	langid = {english},
	file = {Miller - Towards a Uniﬁed Approach to Access Control and Co.pdf:/Users/akilan/Zotero/storage/7METVAKG/Miller - Towards a Uniﬁed Approach to Access Control and Co.pdf:application/pdf},
}

@inproceedings{curtsinger_coz_2015,
	title = {Coz: Finding Code that Counts with Causal Profiling},
	url = {http://arxiv.org/abs/1608.03676},
	doi = {10.1145/2815400.2815409},
	shorttitle = {Coz},
	abstract = {Improving performance is a central concern for software developers. To locate optimization opportunities, developers rely on software proﬁlers. However, these proﬁlers only report where programs spent their time: optimizing that code may have no impact on performance. Past proﬁlers thus both waste developer time and make it difﬁcult for them to uncover signiﬁcant optimization opportunities.},
	pages = {184--197},
	booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
	author = {Curtsinger, Charlie and Berger, Emery D.},
	urldate = {2024-06-07},
	date = {2015-10-04},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1608.03676 [cs]},
	keywords = {C.4, Computer Science - Performance, D.4.8},
	file = {Curtsinger and Berger - 2015 - Coz Finding Code that Counts with Causal Profilin.pdf:/Users/akilan/Zotero/storage/QTFQXVHE/Curtsinger and Berger - 2015 - Coz Finding Code that Counts with Causal Profilin.pdf:application/pdf},
}

@online{noauthor_benchmark_nodate,
	title = {Benchmark {ABI} - {CheriBSD} 23.11 new features tutorial},
	url = {https://www.cheribsd.org/tutorial/23.11/benchmark/index.html},
	urldate = {2024-06-07},
	file = {Benchmark ABI - CheriBSD 23.11 new features tutorial:/Users/akilan/Zotero/storage/9BDKUW28/index.html:text/html},
}

@inproceedings{zhu_research_2018,
	location = {Taipei, Taiwan},
	title = {Research and Implementation of High Performance Traffic Processing Based on Intel {DPDK}},
	isbn = {978-1-5386-9403-9},
	url = {https://ieeexplore.ieee.org/document/8701793/},
	doi = {10.1109/PAAP.2018.00018},
	eventtitle = {2018 9th International Symposium on Parallel Architectures, Algorithms and Programming ({PAAP})},
	pages = {62--68},
	booktitle = {2018 9th International Symposium on Parallel Architectures, Algorithms and Programming ({PAAP})},
	publisher = {{IEEE}},
	author = {Zhu, Wenjun and Li, Peng and Luo, Baozhou and Xu, He and Zhang, Yujie},
	urldate = {2024-06-07},
	date = {2018-12},
}

@article{bi_dpdk-based_2016,
	title = {{DPDK}-based Improvement of Packet Forwarding},
	volume = {7},
	rights = {© Owned by the authors, published by {EDP} Sciences, 2016},
	issn = {2271-2097},
	url = {https://www.itm-conferences.org/articles/itmconf/abs/2016/02/itmconf_ita2016_01009/itmconf_ita2016_01009.html},
	doi = {10.1051/itmconf/20160701009},
	abstract = {Reel-time processing of packets occupies a significant position in the field of computer network security. With theexplosive growth of the backbone link rate,which is consistent with Gilder's law, many bottlenecks of server performance leave the real-time data stream unprocessed.Thus, we proposedto take use of {DPDK}(Data Plan Development Kit) framework to achieve an intelligent {NIC} packet forwarding system. During this research, we deeply analysis the forwarding process of packet in {DPDK} and improve its {DMA} mode.According to the results of experiment, the system greatly enhanced the performance of packet forwarding,and the throughput of forwarding 64-byet or random-length packets by 20Gbit {NIC} reaches13.3Gbps and 18.7Gbps(dual ports forwarding).},
	pages = {01009},
	journaltitle = {{ITM} Web of Conferences},
	shortjournal = {{ITM} Web Conf.},
	author = {Bi, Hao and Wang, Zhao-Hun},
	urldate = {2024-06-07},
	date = {2016},
	langid = {english},
	note = {Publisher: {EDP} Sciences},
	file = {Full Text PDF:/Users/akilan/Zotero/storage/LEVMJ983/Bi and Wang - 2016 - DPDK-based Improvement of Packet Forwarding.pdf:application/pdf},
}

@online{noauthor_arm_nodate,
	title = {Arm Architecture Reference Manual for A-profile architecture},
	url = {https://developer.arm.com/documentation/ddi0487/latest},
	urldate = {2024-06-08},
	file = {Arm Architecture Reference Manual for A-profile architecture:/Users/akilan/Zotero/storage/72DMZYM2/latest.html:text/html},
}

@online{noauthor_getting_nodate,
	title = {Getting Started with {CheriBSD} 23.11 - Getting Started with {CheriBSD} 23.11},
	url = {https://ctsrd-cheri.github.io/cheribsd-getting-started/cover/index.html},
	urldate = {2024-06-08},
	file = {Getting Started with CheriBSD 23.11 - Getting Started with CheriBSD 23.11:/Users/akilan/Zotero/storage/4NSMMRDG/index.html:text/html},
}

@software{noauthor_ctsrd-cheride10pro-cheri-bgas_2024,
	title = {{CTSRD}-{CHERI}/{DE}10Pro-cheri-bgas},
	url = {https://github.com/CTSRD-CHERI/DE10Pro-cheri-bgas},
	abstract = {{CHERI}-{BGAS} {DE}10Pro quartus project},
	publisher = {Capability Hardware Enhanced {RISC} Instructions},
	urldate = {2024-06-08},
	date = {2024-06-03},
	note = {original-date: 2021-06-12T01:21:35Z},
}

@article{esswood_cherios_nodate,
	title = {{CheriOS}: designing an untrusted single-address-space capability operating system utilising capability hardware and a minimal hypervisor},
	author = {Esswood, Lawrence G},
	langid = {english},
	file = {Esswood - CheriOS designing an untrusted single-address-spa.pdf:/Users/akilan/Zotero/storage/YGIBFTD5/Esswood - CheriOS designing an untrusted single-address-spa.pdf:application/pdf},
}

@book{wilkes_cambridge_1979,
	location = {New York},
	title = {The Cambridge {CAP} computer and its operating system},
	isbn = {978-0-444-00357-7 978-0-444-00358-4},
	series = {The computer science library operating and programming systems series},
	pagetotal = {165},
	number = {6},
	publisher = {North Holland},
	author = {Wilkes, Maurice V. and Needham, Roger M.},
	date = {1979},
	langid = {english},
	file = {Wilkes and Needham - 1979 - The Cambridge CAP computer and its operating syste.pdf:/Users/akilan/Zotero/storage/VIQTWZS3/Wilkes and Needham - 1979 - The Cambridge CAP computer and its operating syste.pdf:application/pdf},
}

@article{fillo_mmachine_nodate,
	title = {The M–Machine Multicomputer},
	author = {Fillo, Marco and Keckler, Stephen W and Dally, William J and Carter, Nicholas P and Chang, Andrew and Gurevich, Yevgeny and Lee, Whay S},
	langid = {english},
	file = {Fillo et al. - The M–Machine Multicomputer.pdf:/Users/akilan/Zotero/storage/LD95UQTM/Fillo et al. - The M–Machine Multicomputer.pdf:application/pdf},
}

@inproceedings{kwon_low-fat_2013,
	location = {New York, {NY}, {USA}},
	title = {Low-fat pointers: compact encoding and efficient gate-level implementation of fat pointers for spatial safety and capability-based security},
	isbn = {978-1-4503-2477-9},
	url = {https://dl.acm.org/doi/10.1145/2508859.2516713},
	doi = {10.1145/2508859.2516713},
	series = {{CCS} '13},
	shorttitle = {Low-fat pointers},
	abstract = {Referencing outside the bounds of an array or buffer is a common source of bugs and security vulnerabilities in today's software. We can enforce spatial safety and eliminate these violations by inseparably associating bounds with every pointer (fat pointer) and checking these bounds on every memory access. By further adding hardware-managed tags to the pointer, we make them unforgeable. This, in turn, allows the pointers to be used as capabilities to facilitate fine-grained access control and fast security domain crossing. Dedicated checking hardware runs in parallel with the processor's normal datapath so that the checks do not slow down processor operation (0\% runtime overhead). To achieve the safety of fat pointers without increasing program state, we compactly encode approximate base and bound pointers along with exact address pointers for a 46b address space into one 64-bit word with a worst-case memory overhead of 3\%. We develop gate-level implementations of the logic for updating and validating these compact fat pointers and show that the hardware requirements are low and the critical paths for common operations are smaller than processor {ALU} operations. Specifically, we show that the fat-pointer check and update operations can run in a 4 ns clock cycle on a Virtex 6 (40nm) implementation while only using 1100 6-{LUTs} or about the area of a double-precision, floating-point adder.},
	pages = {721--732},
	booktitle = {Proceedings of the 2013 {ACM} {SIGSAC} conference on Computer \& communications security},
	publisher = {Association for Computing Machinery},
	author = {Kwon, Albert and Dhawan, Udit and Smith, Jonathan M. and Knight, Thomas F. and {DeHon}, Andre},
	urldate = {2024-06-18},
	date = {2013-11-04},
	keywords = {capabilities, fat pointer, memory safety, processor, security, spatial confinement},
	file = {Full Text PDF:/Users/akilan/Zotero/storage/CVVZYZS4/Kwon et al. - 2013 - Low-fat pointers compact encoding and efficient g.pdf:application/pdf},
}

@article{wulf_hydra_1974,
	title = {{HYDRA}: the kernel of a multiprocessor operating system},
	volume = {17},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/355616.364017},
	doi = {10.1145/355616.364017},
	shorttitle = {{HYDRA}},
	abstract = {This paper describes the design philosophy of {HYDRA}—the kernel of an operating system for C.mmp, the Carnegie-Mellon Multi-Mini-Processor. This philosophy is realized through the introduction of a generalized notion of “resource,” both physical and virtual, called an “object.” Mechanisms are presented for dealing with objects, including the creation of new types, specification of new operations applicable to a given type, sharing, and protection of any reference to a given object against improper application of any of the operations defined with respect to that type of object. The mechanisms provide a coherent basis for extension of the system in two directions: the introduction of new facilities, and the creation of highly secure systems.},
	pages = {337--345},
	number = {6},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Wulf, W. and Cohen, E. and Corwin, W. and Jones, A. and Levin, R. and Pierson, C. and Pollack, F.},
	urldate = {2024-06-18},
	date = {1974-06},
	langid = {english},
	file = {Full Text:/Users/akilan/Zotero/storage/EIRBNTVF/Wulf et al. - 1974 - HYDRA the kernel of a multiprocessor operating sy.pdf:application/pdf},
}

@article{hardy_keykos_1985,
	title = {{KeyKOS} architecture},
	volume = {19},
	issn = {0163-5980},
	url = {https://dl.acm.org/doi/10.1145/858336.858337},
	doi = {10.1145/858336.858337},
	pages = {8--25},
	number = {4},
	journaltitle = {{ACM} {SIGOPS} Operating Systems Review},
	shortjournal = {{SIGOPS} Oper. Syst. Rev.},
	author = {Hardy, Norman},
	urldate = {2024-06-18},
	date = {1985-10-01},
	file = {Full Text PDF:/Users/akilan/Zotero/storage/QSYKM6QN/Hardy - 1985 - KeyKOS architecture.pdf:application/pdf},
}

@article{rashid_mach_nodate,
	title = {Mach: A System Software Kernel},
	abstract = {The Mach operating system can be used as a system software kernel which can support a variety of operating system environments. Key elements of the Mach design which allow it to efficiently support system software include integrated virtual memory management and interprocess communication, multiple threads of control within one address space, support for transparent system trap callout and an object programming facility integrated with the Mach {IPC} mechanisms. Mach is currently available both from {CMU} and commercially on a wide range of uniprocessor and multiprocessor hardware.},
	author = {Rashid, Richard and Julin, Daniel and Orr, Douglas and Sanzi, Richard and Baron, Robert and Forin, Alessandro and Golub, David and Jones, Michael},
	langid = {english},
	file = {Rashid et al. - Mach A System Software Kernel.pdf:/Users/akilan/Zotero/storage/UHLILYH9/Rashid et al. - Mach A System Software Kernel.pdf:application/pdf},
}

@inproceedings{baumann_multikernel_2009,
	location = {Big Sky Montana {USA}},
	title = {The multikernel: a new {OS} architecture for scalable multicore systems},
	isbn = {978-1-60558-752-3},
	url = {https://dl.acm.org/doi/10.1145/1629575.1629579},
	doi = {10.1145/1629575.1629579},
	shorttitle = {The multikernel},
	abstract = {Commodity computer systems contain more and more processor cores and exhibit increasingly diverse architectural tradeoﬀs, including memory hierarchies, interconnects, instruction sets and variants, and {IO} conﬁgurations. Previous high-performance computing systems have scaled in speciﬁc cases, but the dynamic nature of modern client and server workloads, coupled with the impossibility of statically optimizing an {OS} for all workloads and hardware variants pose serious challenges for operating system structures.},
	eventtitle = {{SOSP}09: {ACM} {SIGOPS} 22nd Symposium on Operating Systems Principles},
	pages = {29--44},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 22nd symposium on Operating systems principles},
	publisher = {{ACM}},
	author = {Baumann, Andrew and Barham, Paul and Dagand, Pierre-Evariste and Harris, Tim and Isaacs, Rebecca and Peter, Simon and Roscoe, Timothy and Schüpbach, Adrian and Singhania, Akhilesh},
	urldate = {2024-06-18},
	date = {2009-10-11},
	langid = {english},
	file = {Baumann et al. - 2009 - The multikernel a new OS architecture for scalabl.pdf:/Users/akilan/Zotero/storage/4BVCRZN6/Baumann et al. - 2009 - The multikernel a new OS architecture for scalabl.pdf:application/pdf},
}

@article{watson_capsicum_nodate,
	title = {Capsicum: practical capabilities for {UNIX}},
	abstract = {Capsicum is a lightweight operating system capability and sandbox framework planned for inclusion in {FreeBSD} 9. Capsicum extends, rather than replaces, {UNIX} {APIs}, providing new kernel primitives (sandboxed capability mode and capabilities) and a userspace sandbox {API}. These tools support compartmentalisation of monolithic {UNIX} applications into logical applications, an increasingly common goal supported poorly by discretionary and mandatory access control. We demonstrate our approach by adapting core {FreeBSD} utilities and Google’s Chromium web browser to use Capsicum primitives, and compare the complexity and robustness of Capsicum with other sandboxing techniques.},
	author = {Watson, Robert N M and Anderson, Jonathan and Kennaway, Kris and Laurie, Ben},
	langid = {english},
	file = {Watson et al. - Capsicum practical capabilities for UNIX.pdf:/Users/akilan/Zotero/storage/IAFXHJ8H/Watson et al. - Capsicum practical capabilities for UNIX.pdf:application/pdf},
}

@online{noauthor_department_nodate,
	title = {Department of Computer Science and Technology: {CheriBSD}},
	url = {https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheribsd.html},
	urldate = {2024-06-18},
	file = {Department of Computer Science and Technology\: CheriBSD:/Users/akilan/Zotero/storage/3XQJWCXD/cheribsd.html:text/html},
}

@online{noauthor_msrc-security-researchpapers2020security_nodate,
	title = {{MSRC}-Security-Research/papers/2020/Security analysis of {CHERI} {ISA}.pdf at master · microsoft/{MSRC}-Security-Research},
	url = {https://github.com/microsoft/MSRC-Security-Research/blob/master/papers/2020/Security%20analysis%20of%20CHERI%20ISA.pdf},
	abstract = {Security Research from the Microsoft Security Response Center ({MSRC}) - microsoft/{MSRC}-Security-Research},
	titleaddon = {{GitHub}},
	urldate = {2024-06-18},
	langid = {english},
	file = {Snapshot:/Users/akilan/Zotero/storage/ENF2KYRT/Security analysis of CHERI ISA.html:text/html},
}

@inproceedings{zaliva_formal_2024,
	location = {La Jolla {CA} {USA}},
	title = {Formal Mechanised Semantics of {CHERI} C: Capabilities, Undefined Behaviour, and Provenance},
	isbn = {9798400703720},
	url = {https://dl.acm.org/doi/10.1145/3617232.3624859},
	doi = {10.1145/3617232.3624859},
	shorttitle = {Formal Mechanised Semantics of {CHERI} C},
	abstract = {Memory safety issues are a persistent source of security vulnerabilities, with conventional architectures and the C codebase chronically prone to exploitable errors. The {CHERI} research project has shown how one can provide radically improved security for that existing codebase with minimal modification, using unforgeable hardware capabilities in place of machine-word pointers in {CHERI} dialects of C, implemented as adaptions of Clang/{LLVM} and {GCC}. {CHERI} was first prototyped as extensions of {MIPS} and {RISC}-V; it is currently being evaluated by Arm and others with the Arm Morello experimental architecture, processor, and platform, to explore its potential for mass-market adoption, and by Microsoft in their {CHERIoT} design for embedded cores.},
	eventtitle = {{ASPLOS} '24: 29th {ACM} International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 1},
	pages = {181--196},
	booktitle = {Proceedings of the 29th {ACM} International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 1},
	publisher = {{ACM}},
	author = {Zaliva, Vadim and Memarian, Kayvan and Almeida, Ricardo and Clarke, Jessica and Davis, Brooks and Richardson, Alexander and Chisnall, David and Campbell, Brian and Stark, Ian and Watson, Robert N. M. and Sewell, Peter},
	urldate = {2024-06-18},
	date = {2024-04-27},
	langid = {english},
	file = {Zaliva et al. - 2024 - Formal Mechanised Semantics of CHERI C Capabiliti.pdf:/Users/akilan/Zotero/storage/8Y2CRHBS/Zaliva et al. - 2024 - Formal Mechanised Semantics of CHERI C Capabiliti.pdf:application/pdf},
}

@article{watson_cheri_nodate,
	title = {{CHERI} C/C++ Programming Guide},
	abstract = {This document is a brief introduction to the {CHERI} C/C++ programming languages. We explain the principles underlying these language variants, and their grounding in {CHERI}’s multiple architectural instantiations: {CHERI}-{MIPS}, {CHERI}-{RISC}-V, and Arm’s Morello. We describe the most commonly encountered differences between these dialects and C/C++ on conventional architectures, and where existing software may require minor changes. We document new compiler warnings and errors that may be experienced compiling code with the {CHERI} Clang/{LLVM} compiler, and suggest how they may be addressed through typically minor source-code changes. We explain how modest language extensions allow selected software, such as memory allocators, to further reﬁne permissions and bounds on pointers. This guidance is based on our experience adapting the {FreeBSD} operating-system userspace, and applications such as {PostgreSQL} and {WebKit}, to run in a {CHERI} C/C++ capability-based programming environment. We conclude by recommending further reading.},
	author = {Watson, Robert N M and Richardson, Alexander and Davis, Brooks and Baldwin, John and Chisnall, David and Clarke, Jessica and Filardo, Nathaniel and Moore, Simon W and Napierala, Edward and Sewell, Peter and Neumann, Peter G},
	langid = {english},
	file = {Watson et al. - CHERI CC++ Programming Guide.pdf:/Users/akilan/Zotero/storage/WHGQXE8P/Watson et al. - CHERI CC++ Programming Guide.pdf:application/pdf},
}

@article{esswood_cherios_nodate-1,
	title = {{CheriOS}: designing an untrusted single-address-space capability operating system utilising capability hardware and a minimal hypervisor},
	author = {Esswood, Lawrence G},
	langid = {english},
	file = {Esswood - CheriOS designing an untrusted single-address-spa.pdf:/Users/akilan/Zotero/storage/3IVKGYZ5/Esswood - CheriOS designing an untrusted single-address-spa.pdf:application/pdf},
}

@online{noauthor_architecture_nodate,
	title = {The Architecture  of the Burroughs B-5000},
	url = {https://www.smecc.org/The%20Architecture%20%20of%20the%20Burroughs%20B-5000.htm},
	urldate = {2024-06-18},
	file = {The Architecture  of the Burroughs B-5000:/Users/akilan/Zotero/storage/ELNL8VBQ/The Architecture  of the Burroughs B-5000.html:text/html},
}

@article{dennis_programming_1966,
	title = {Programming semantics for multiprogrammed computations},
	volume = {9},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/365230.365252},
	doi = {10.1145/365230.365252},
	abstract = {The semantics are defined for a number of meta-instructions which perform operations essential to the writing of programs in multiprogrammed computer systems. These meta-instructions relate to parallel processing, protecting of separate computations, program debugging, and the sharing among users of memory segments and other computing objects, the names of which are hierarchically structured. The language sophistication contemplated is midway between an assembly language and an advanced algebraic language.},
	pages = {143--155},
	number = {3},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Dennis, Jack B. and Van Horn, Earl C.},
	urldate = {2024-06-18},
	date = {1966-03},
	langid = {english},
	file = {Full Text:/Users/akilan/Zotero/storage/6MLX2U8V/Dennis and Van Horn - 1966 - Programming semantics for multiprogrammed computat.pdf:application/pdf},
}

@article{watson_capability_nodate,
	title = {Capability Hardware Enhanced {RISC} Instructions: {CHERI} Instruction-Set Architecture (Version 8)},
	abstract = {This technical report describes {CHERI} {ISAv}8, the eighth version of the {CHERI} architecture being developed by {SRI} International and the University of Cambridge. This design captures ten years of research, development, experimentation, reﬁnement, formal analysis, and validation through hardware and software implementation.},
	author = {Watson, Robert N M and Neumann, Peter G and Woodruff, Jonathan and Roe, Michael and Almatary, Hesham and Anderson, Jonathan and Baldwin, John and Barnes, Graeme and Chisnall, David and Clarke, Jessica and Davis, Brooks and Eisen, Lee and Filardo, Nathaniel Wesley and Grisenthwaite, Richard and Joannou, Alexandre and Laurie, Ben and Markettos, A Theodore and Moore, Simon W and Murdoch, Steven J and Nienhuis, Kyndylan and Norton, Robert and Richardson, Alexander and Rugg, Peter and Sewell, Peter and Son, Stacey and Xia, Hongyan},
	langid = {english},
	file = {Watson et al. - Capability Hardware Enhanced RISC Instructions CH.pdf:/Users/akilan/Zotero/storage/R9T374YS/Watson et al. - Capability Hardware Enhanced RISC Instructions CH.pdf:application/pdf},
}

@online{noauthor_-it-yourself_nodate,
	title = {Do-It-Yourself Virtual Memory Translation {\textbar} {ACM} {SIGARCH} Computer Architecture News},
	url = {https://dl.acm.org/doi/10.1145/3140659.3080209},
	urldate = {2024-06-18},
}

@online{noauthor_hugetlbfs_nodate,
	title = {Hugetlbfs Reservation — The Linux Kernel documentation},
	url = {https://www.kernel.org/doc/html/v4.18/vm/hugetlbfs_reserv.html},
	urldate = {2024-06-18},
	file = {Hugetlbfs Reservation — The Linux Kernel documentation:/Users/akilan/Zotero/storage/AV8UT59L/hugetlbfs_reserv.html:text/html},
}